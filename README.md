# Cryptography LR2 — алгоритмы и запуск

Этот репозиторий содержит три учебных модуля:

- **AKSC** — шифр с автоматическим выбором ключа (autokey по открытому тексту);
- **LFSR** — регистр сдвига с линейной обратной связью (генератор ключевого потока);
- **SSC** — синхронный потоковый шифр на базе LFSR (XOR-шифрование байт-строка).

> Проект учебный. Реализации **не предназначены** для защиты реальных данных.

---

## Быстрый старт

### Установка зависимостей

Зависимости управляются через `pyproject.toml` и `uv.lock`:
```bash
pip install uv
uv sync
```

### Переменные окружения

Создайте и заполните `.env`:

```bash
cp .env.example .env
```

Общие:

- `SECRET_DATA` — произвольная строка
- `ALFABET_POWER` — мощность алфавита (int), например `1_114_111`

AKSC:

- `AKSC_KEY` — начальный ключ (один символ)

LFSR / SSC:

- `SEED` — двоичная строка начального состояния регистра
- `TAB_BITS` — номера разрядов обратной связи (целые, через пробел)

### Запуск примеров
```bash
source ./venv/bin/activate
python3 aksc.py
```
```bash
source ./venv/bin/activate
python3 ssc.py
```

---

## Краткая сводка по шифрам

| Алгоритм                               | Синхронность                                                                                     | Ключевая модель                                                                     | Тип шифра                               |
|----------------------------------------|--------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|-----------------------------------------|
| **AKSC** (autokey по открытому тексту) | **Несинхронный**: ключевой символ на шаге *i* зависит от предыдущего **открытого** символа       | **Одноключевой**: один начальный ключ (1 символ), далее ключ генерируется из текста | **Потоковый**: помесимвольная обработка |
| **SSC** (XOR с ключевым потоком LFSR)  | **Синхронный**: ключевой поток не зависит от текста/шифртекста, определяется `SEED` и `TAB_BITS` | **Одноключевой**: единый секрет — пара (`SEED`, `TAB_BITS`)                         | **Потоковый**: побайтное XOR            |

> Примечание: **LFSR** сам по себе не является шифром, а генератором псевдослучайной последовательности, используемой в
*SSC* как ключевой поток.

---

## Описания и интерфейсы

### 1) AKSC — шифр с автоматическим выбором ключа

Файл: `aksc.py`  
Идея: на шаге *i* шифруем `y[i] = (ord(x[i]) + ord(k)) mod n`, после чего **обновляем ключ** `k = x[i]`. Для
расшифрования: `x[i] = (ord(y[i]) - ord(k)) mod n`, далее `k = x[i]`.  
Свойства:

- Требует **один начальный ключ** (символ).
- Ошибка/потеря символа ведёт к **каскадной рассинхронизации**, т.к. ключ зависит от предыдущего **открытого** символа.
- Работает **помеcимвольно** (потоковый принцип).

Интерфейс:

```python
encrypt(plaintext: str, key: str, n: int) -> str
decrypt(ciphertext: str, key: str, n: int) -> str
```

Где `n` — мощность алфавита.

### 2) LFSR — генератор ключевого потока

Файл: `lfsr.py`  
Идея: регистр сдвига, новый бит — XOR выбранных разрядов (taps).  
Свойства:

- Источник **детерминированной** псевдослучайной битовой последовательности при фиксированных `SEED`, `TAB_BITS`.
- В учебных целях. Для криптографии LFSR требуется композиция/маскирование (одиночный LFSR уязвим).

Интерфейс:

```python
LFSR(seed: str, tab_bits: list[int])
lfsr() -> str  # выдает блок длиной len(seed)
lfsr_gen() -> Iterator  # бесконечный генератор бит ('0'/'1')
```

### 3) SSC — синхронный потоковый шифр на базе LFSR

Файл: `ssc.py`  
Идея: формируем байты ключевого потока, собирая по 8 бит из `LFSR.lfsr_gen()`, затем применяем XOR помежду байтами
открытого текста/шифртекста и ключевого потока.

Интерфейс:

```python
encrypt(text: str, keystream_bits: Iterator[str]) -> bytes
decrypt(cipher: bytes, keystream_bits: Iterator[str]) -> str
```

Характеристики:

- **Синхронный**: одинаковый поток ключа при совпадающих `SEED`, `TAB_BITS`.
- **Одноключевой**: секрет — параметры LFSR.
- **Потоковый**: XOR побайтно; шифрование == дешифрование одной и той же функцией над разными входами.

---

## Примеры использования

### AKSC

```python
from aksc import encrypt, decrypt
from static import PLAINTEXT, AKSC_KEY, ALFABET_POWER

cipher = encrypt(PLAINTEXT, AKSC_KEY, ALFABET_POWER)
plain = decrypt(cipher, AKSC_KEY, ALFABET_POWER)
```

### SSC

```python
from ssc import encrypt, decrypt
from lfsr import LFSR
from static import SEED, TAB_BITS

l = LFSR(SEED, TAB_BITS)
cipher_hex = encrypt("hello", l.lfsr_gen()).hex()

# для расшифрования генератор ключа должен стартовать из того же состояния!
l = LFSR(SEED, TAB_BITS)
plain = decrypt(bytes.fromhex(cipher_hex), l.lfsr_gen())
```

---

## Замечания по безопасности

- **AKSC** и одиночный **LFSR** уязвимы и применяются здесь **только для обучения**.
- Для реального применения требуются современные алгоритмы (AES-GCM, ChaCha20-Poly1305 и т.п.) и корректные протоколы
  управления ключами.

---

## Лицензия

MIT (если иное не указано в репозитории).
